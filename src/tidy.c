/*
 * $Id: tidy.c 745 2004-05-23 07:58:24Z skaar $
 *
 * Copyright (C) 1995-2004 Free Software Foundation, Inc.
 *
 * This file is part of cfng, a fork of GNU cfengine. Modifications,
 * additions and other differences herein is not releated to or
 * associated with the original project.
 *
 * This file is derived from GNU cfengine - written by Mark Burgess,
 * Dept of Computing and Engineering, Oslo College, Dept. of Theoretical
 * physics, University of Oslo.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
 * USA
 */

#include "cf.defs.h"
#include "cf.extern.h"

/*
 * Tidy object
 */

int
RecursiveHomeTidy(char *name,int level,struct stat *sb)
{
    struct stat statbuf;
    DIR *dirh;
    struct dirent *dirp;
    char pcwd[CF_BUFSIZE];
    time_t ticks;
    int done = false,goback;

    Debug("\n RecursiveHomeTidy(%s,%d)\n\n",name,level);

    if (!DirPush(name,sb)) {
        return false;
    }

    if (strlen(name) == 0) {
        name = "/";
    }

    if (level > CF_RECURSION_LIMIT) {
        snprintf(g_output, CF_BUFSIZE*2,
                "WARNING: Very deep nesting of directories "
                "(> %d deep): %s (Aborting tidy)", level, name);
        CfLog(cferror,g_output,"");
        return true;
    }

    Debug2("HomeTidy: Opening %s as .\n",name);

    if ((dirh = opendir(".")) == NULL) {
        snprintf(g_output,CF_BUFSIZE*2,"Can't open directory %s\n",name);
        CfLog(cfverbose,g_output,"opendir");
        return true;
    }

    if (level == 2) {
        if (g_logtidyhomefiles) {
            int tempfd;
            strcpy(g_vlogfile,name);
            strcat(g_vlogfile,"/.cfng.rm");

            /* 
             * Unlink here to avoid an exploit which could be used to
             * overwrite a system file with root privileges. 
             */

            if (unlink(g_vlogfile) == -1) {
                Debug("Pre-existing object %s could not be removed\n",
                        g_vlogfile);
            }

            if ((tempfd = open(g_vlogfile, O_CREAT|O_EXCL|O_WRONLY,0600)) < 0) {
                snprintf(g_output,CF_BUFSIZE,
                        "Couldn't open a file %s\n",g_vlogfile);
                CfLog(cferror,g_output,"open");
                g_vlogfp = stderr;
            } else if ((g_vlogfp = fdopen(tempfd,"w")) == NULL) {
                sprintf(g_output,"Couldn't open a file %s\n",g_vlogfile);
                CfLog(cferror,g_output,"fdopen");
                g_vlogfp = stderr;
            } else {
                ticks = time((time_t *)NULL);

                fprintf(g_vlogfp,"This file is generated by cfng %s\n", 
                        VERSION);
                fprintf(g_vlogfp,"It contains a log of the files "
                        "which have been tidied.\n");

                fprintf(g_vlogfp,"The time of writing is %s\n",ctime(&ticks));
                fprintf(g_vlogfp,"If you have any questions about this, "
                        "send them to %s.\n",g_vsysadm);
                fprintf(g_vlogfp, "-(Start transcript)---------------\n");

            }
        }
    }

    for (dirp = readdir(dirh); dirp != NULL; dirp = readdir(dirh)) {
        if (!SensibleFile(dirp->d_name,name,NULL)) {
            continue;
        }

            /* No ref to tp->ignores here...fix?*/
        if (IgnoreFile(name,dirp->d_name,NULL)) {
            continue;
        }

        /* Assemble pathname */
        strcpy(pcwd,name);
        AddSlash(pcwd);

        if (BufferOverflow(pcwd,dirp->d_name)) {
            return true;
        }

        strcat(pcwd,dirp->d_name);

        if (g_travlinks) {

            Verbose("Warning: you are using travlinks=true. "
                    "It is a potential security hazard if there "
                    "are untrusted users\n");

            if (lstat(dirp->d_name,&statbuf) == -1) {
                snprintf(g_output,CF_BUFSIZE*2,"Can't stat %s\n",pcwd);
                CfLog(cferror,g_output,"stat");
                continue;
            }

            if (S_ISLNK(statbuf.st_mode) && (statbuf.st_mode != getuid())) {

                snprintf(g_output, CF_BUFSIZE, 
                        "File %s is an untrusted link. "
                        "cfagent will not follow it with "
                        "a destructive operation (tidy)",pcwd);

                CfLog(cfinform,g_output,"");
                continue;
            }

            if (stat(dirp->d_name,&statbuf) == -1) {
                snprintf(g_output,CF_BUFSIZE*2,"Can't stat %s\n",pcwd);
                CfLog(cferror,g_output,"stat");
                continue;
            }
        } else {
            if (lstat(pcwd,&statbuf) == -1) {
                if (g_debug || g_d2 || g_verbose) {
                    snprintf(g_output,CF_BUFSIZE*2,"Can't stat %s\n",pcwd);
                    CfLog(cferror,g_output,"lstat");
                    memset(g_vbuff,0,CF_BUFSIZE);

                    if (readlink(pcwd,g_vbuff,CF_BUFSIZE-1) != -1) {
                        snprintf(g_output,CF_BUFSIZE*2,
                                "File is link to -> %s\n",g_vbuff);
                        CfLog(cferror,g_output,"");
                    }
                }
                continue;
            }
        }


        if (S_ISDIR(statbuf.st_mode)) {
            if (IsMountedFileSystem(&statbuf,pcwd,1)) {
                continue;
            } else {

                /* 
                 * Note, here we pass on the full path name, not
                 * relative name to retain state, but we have statted
                 * the right file above with opendir("."), so the race
                 * test is still secure for the next recursion level 
                 */

                if (!done) {
                    goback = RecursiveHomeTidy(pcwd,level+1,&statbuf);
                    DirPop(goback,name,sb);
                }
            }
        } else {
            if (!TidyHomeFile(pcwd,dirp->d_name,&statbuf,level)) {
                done = true;
            }
        }
    }

    if (level == 2) {
        if (g_logtidyhomefiles) {
            fclose(g_vlogfp);
            chmod(g_vlogfile,g_defaultmode);
        }
    }
    closedir(dirh);
    return true;
}


/* 
 * Tidy a file if it's past its sell-by date in kB, and if it is greater
 * than the specified size. Don't need an OR, since size age can just be
 * set to zero. 
 */
int
TidyHomeFile(char *path,char *name, struct stat *statbuf,int level)
{
    struct Tidy *tp;
    struct TidyPattern *tlp;
    short savetravlinks = g_travlinks, savekilloldlinks = g_killoldlinks;

    /* 
     * Note that we have to go through the whole tidy list here, even
     * non-home, so be careful to pick out the rules the affect us! The
     * info about home dissappears here, since we have expanded the
     * home/ directive into an actual path, so we make sure that no
     * non-home rules can be applied to home directories 
     */

    for (tp = g_vtidy; tp != NULL; tp=tp->next) {
        if ((strncmp(tp->path,"home/",5) != 0) &&
                (strcmp(tp->path,"home") != 0)) {
            continue;
        }

        if (tp->tidylist == NULL || tp->done == 'y') {
            continue;
        }

        Debug("  Check rule %s ...\n",tp->path);

        if ((tp->maxrecurse != CF_INF_RECURSE) && (level > tp->maxrecurse+1)) {

            Debug("Recursion maxed out at level %d/%d\n",
                    level,tp->maxrecurse+1);

            /*return false;*/
            continue;
        }

        for (tlp = tp->tidylist; tlp != NULL; tlp=tlp->next) {
            if (IsExcluded(tlp->classes)) {
                continue;
            }

            savetravlinks = g_travlinks;
            savekilloldlinks = g_killoldlinks;

            ResetOutputRoute(tlp->log,tlp->inform);

            if (tlp->travlinks == 'T') {
                g_travlinks = true;
            } else if (tlp->travlinks == 'F') {
                g_travlinks = false;
            } else if (tlp->travlinks == 'K') {
                g_killoldlinks = true;
            }


            if (!FileObjectFilter(path,statbuf,tlp->filters,tidy)) {
                continue;
            }

            if (IgnoredOrExcluded(tidy,path,NULL,tp->exclusions)) {
                Debug("Skipping ignored/excluded file %s\n",path);
                continue;
            }

            if (WildMatch(tlp->pattern,name) &&
                    CheckHomeSubDir(path,tp->path,tp->maxrecurse)) {
                if ((tlp->recurse != CF_INF_RECURSE) &&
                        (level > tlp->recurse+1)) {
                    Debug("Not tidying %s - level %d > limit %d\n",
                            path,level,tlp->recurse+1);
                    continue;
                }
                DoTidyFile(path, name, tlp, statbuf, CF_USELOGFILE, 
                        false, false);
            }

            ResetOutputRoute('d','d');
        }
    }

    g_travlinks = savetravlinks;
    g_killoldlinks = savekilloldlinks;
    return true;
}

/* ----------------------------------------------------------------- */

int
RecursiveTidySpecialArea(char *name,struct Tidy *tp,int maxrecurse,
        struct stat *sb)
{
    struct stat statbuf,topstatbuf;
    DIR *dirh;
    struct dirent *dirp;
    char pcwd[CF_BUFSIZE];
    int is_dir,level,goback;

    Debug("RecursiveTidySpecialArea(%s)\n",name);
    memset(&statbuf,0,sizeof(statbuf));

    if (!DirPush(name,sb)) {
        return false;
    }

    if (maxrecurse == -1) {
        Debug2("MAXRECURSE ran out, quitting at %s\n",name);
        return true;
    }

    if (IgnoredOrExcluded(tidy,name,NULL,tp->exclusions)) {
        Debug("Skipping ignored/excluded file %s\n",name);
        return true;
    }

    if (IgnoreFile(name,"",tp->ignores)) {
        Debug2("cfagent: Ignoring directory %s\n",name);
        return true;
    }

    if (strlen(name) == 0) {     /* Check for root dir */
        name = (char *) malloc(2);
        name[0] = '/';
        name[1] = '\0';
    }

    if (maxrecurse == tp->maxrecurse) {
        if (lstat(name,&topstatbuf) == -1) {
            if (g_debug || g_d2 || g_verbose) {
                snprintf(g_output,CF_BUFSIZE*2,"Can't stat %s\n",name);
                CfLog(cferror,g_output,"");
                memset(g_vbuff,0,CF_BUFSIZE);

                if (readlink(name,g_vbuff,CF_BUFSIZE-1) != -1) {
                    snprintf(g_output, CF_BUFSIZE*2,
                            "File is link to -> %s\n", g_vbuff);
                    CfLog(cferror,g_output,"");
                }
            }
            return true;
        }
    }

    if ((dirh = opendir(".")) == NULL) {
        snprintf(g_output,CF_BUFSIZE*2,"Can't open directory [%s]\n",name);
        CfLog(cfverbose,g_output,"opendir");
        return true;
    }

    Debug("Tidy: opening dir %s\n",name);

    for (dirp = readdir(dirh); dirp != NULL; dirp = readdir(dirh)) {
        if (!SensibleFile(dirp->d_name,name,NULL)) {
            continue;
        }

        if (IgnoreFile(name,dirp->d_name,tp->ignores)) {
            continue;
        }

        /* Assemble pathname */
        strcpy(pcwd,name);
        AddSlash(pcwd);

        if (BufferOverflow(pcwd,dirp->d_name)) {
            return true;
        }

        strcat(pcwd,dirp->d_name);

        /* Check for links first */
        if (lstat(dirp->d_name,&statbuf) == -1) {
            Verbose("Can't stat %s (%s)\n",dirp->d_name,pcwd);
            continue;
        } else {
            if (S_ISLNK(statbuf.st_mode) && (statbuf.st_uid != getuid())) {

                snprintf(g_output, CF_BUFSIZE, 
                        "File %s is an untrusted link."
                        "cfagent will not follow it with "
                        "a destructive operation (tidy)", pcwd);

                continue;
            }
        }

        if (g_travlinks && (stat(dirp->d_name,&statbuf) == -1)) {
            Verbose("Can't stat %s (%s)\n",dirp->d_name,pcwd);
            continue;
        }

        if (tp->xdev =='y' && DeviceChanged(statbuf.st_dev)) {
            Verbose("Skipping %s on different device\n",pcwd);
            continue;
        }

        if (S_ISDIR(statbuf.st_mode)) {
            is_dir =  true;
        } else {
            is_dir = false;
        }

        level = tp->maxrecurse - maxrecurse;

        /* note lstat above! */
        if (S_ISDIR(statbuf.st_mode)) {
            if (IsMountedFileSystem(&statbuf,pcwd,1)) {
                continue;
            } else {

                /* 
                 * Note, here we pass on the full path name, not
                 * relative name to retain state, but we have statted
                 * the right file above with opendir("."), so the race
                 * test is still secure for the next recursion level 
                 */

                goback = RecursiveTidySpecialArea(pcwd,tp,
                        maxrecurse-1,&statbuf);
                DirPop(goback,name,sb);
            }
            TidyParticularFile(pcwd, dirp->d_name, tp, &statbuf, is_dir,
                    level, false);
        } else {
            TidyParticularFile(pcwd, dirp->d_name, tp,&statbuf, is_dir, 
                    level, false);
        }
    }

    closedir(dirh);

    if (maxrecurse == tp->maxrecurse) {
        Debug("Checking tidy topmost directory %s\n",name);
        chdir("/");

        TidyParticularFile(name, ReadLastNode(name), tp, &topstatbuf, true,
                tp->maxrecurse, true);
    }
    return true;
}

/* ----------------------------------------------------------------- */

void TidyParticularFile(char *path, char *name, struct Tidy *tp,
        struct stat *statbuf, int is_dir, int level, int usepath)
{
    struct TidyPattern *tlp;
    short savekilloldlinks = g_killoldlinks;

    Debug2("TidyParticularFile(%s,%s)\n",path,name);

    if (tp->tidylist == NULL) {
        return;
    }

    for (tlp = tp->tidylist; tlp != NULL; tlp=tlp->next) {
        if (IsExcluded(tlp->classes)) {
            continue;
        }

        ResetOutputRoute(tlp->log,tlp->inform);

        /* Keep links to directories */
        if (S_ISLNK(statbuf->st_mode) &&
                is_dir && (tlp->dirlinks == 'k') &&
                (tlp->rmdirs == 'n')) {

            ResetOutputRoute('d','d');
            continue;
        }

        savekilloldlinks = g_killoldlinks;

        if (tlp->travlinks == 'K') {
            g_killoldlinks = true;
        }

        /* No point in checking permission on a link */
        if (S_ISLNK(statbuf->st_mode)) {
            Debug("Checking for dead links\n");
            if (tlp != NULL) {
                KillOldLink(path,tlp->defines);
            } else {
                KillOldLink(path,NULL);
            }
            continue;
        }

        g_killoldlinks = savekilloldlinks;

        /* not allowed to rmdir */
        if (is_dir && tlp->rmdirs == 'n') {
            ResetOutputRoute('d','d');
            continue;
        }

        /* rmdir subdirs only */
        if ((level == tp->maxrecurse) && tlp->rmdirs == 's') {
            ResetOutputRoute('d','d');
            continue;
        }

        if (level > tlp->recurse && tlp->recurse != CF_INF_RECURSE) {
            Debug2(
                "[PATTERN %s RECURSE ENDED at %d(%d) BEFORE MAXVAL %d]\n",
                tlp->pattern, level,tlp->recurse,tp->maxrecurse);
            ResetOutputRoute('d','d');
            continue;
        }

        if (IsExcluded(tlp->classes)) {
            ResetOutputRoute('d','d');
            continue;
        }

        if (!WildMatch(tlp->pattern,name)) {
            Debug("Pattern did not match (first filter %s) %s\n",
                    tlp->pattern,path);
            ResetOutputRoute('d','d');
            continue;
        }

        if (!FileObjectFilter(path,statbuf,tlp->filters,tidy)) {
            Debug("Skipping filtered file %s\n",path);
            continue;
        }

        if (IgnoredOrExcluded(tidy,path,NULL,tp->exclusions)) {
            Debug("Skipping ignored/excluded file %s\n",path);
            continue;
        }

        if (S_ISLNK(statbuf->st_mode) && is_dir && (tlp->dirlinks == 'y')) {
            Debug("Link to directory, dirlinks= says delete these\n");
        } else if (is_dir && !EmptyDir(path)) {
            Debug("Non-empty directory %s, skipping..\n",path);
            ResetOutputRoute('d','d');
            continue;
        }

        Debug2("Matched %s to %s in %s\n",name,tlp->pattern,path);
        DoTidyFile(path, name, tlp, statbuf, CF_NOLOGFILE, is_dir, usepath);
        ResetOutputRoute('d','d');
    }
}

/*
 * --------------------------------------------------------------------
 * Level 2
 * --------------------------------------------------------------------
 */

void
DoTidyFile(char *path, char *name, struct TidyPattern *tlp,
        struct stat *statbuf, short logging_this, int isreallydir,
        int usepath)
{
    time_t nowticks, fileticks = 0;
    int size_match = false, age_match = false;

    Debug2("DoTidyFile(%s,%s)\n",path,name);

    /* 
     * Here we can assume that we are in the right directory with
     * chdir()! 
     */

    /* cmp time in days */
    nowticks = time((time_t *)NULL);

    switch (tlp->searchtype) {
    case 'a':
        fileticks = statbuf->st_atime;
        break;
    case 'm':
        fileticks = statbuf->st_mtime;
        break;
    case 'c':
        fileticks = statbuf->st_ctime;
        break;
    default:
        printf("cfagent: Internal error in DoTidyFile()\n");
        break;
    }

    /* 
     * Directory age comparison by mtime, since examining will always
     * alter atime 
     */
    if (isreallydir) {
        fileticks = statbuf->st_mtime;
    }

    if (nowticks-fileticks < 0) {
        snprintf(g_output,CF_BUFSIZE*2,
                "ALERT: atime for %s is in the future. Check system clock!\n",
                path);
        CfLog(cfinform,g_output,"");
        return;
    }

    if (tlp->size == CF_EMPTYFILE) {
        if (statbuf->st_size == 0) {
            size_match = true;
        } else {
            size_match = false;
        }
    } else {
        size_match = (tlp->size <= statbuf->st_size);
    }

    age_match = tlp->age*CF_TICKS_PER_DAY <= (nowticks-fileticks);

    if (age_match && size_match) {
        if (logging_this) {
            if (g_vlogfp != NULL) {
                fprintf(g_vlogfp,"cf: rm %s\n",path);
            }
        }

        if (! g_dontdo) {
            if (S_ISDIR(statbuf->st_mode)) {
                snprintf(g_output,CF_BUFSIZE*2,"Deleting directory %s\n",path);
                CfLog(cfinform,g_output,"");

                if (usepath) {
                    if (rmdir(path) == -1) {
                        Debug("Special case remove top level %s\n",path);
                        snprintf(g_output, CF_BUFSIZE*2, 
                                "Delete top directory %s failed\n", path);
                        CfLog(cferror, g_output, "unlink");
                    } else {
                        AddMultipleClasses(tlp->defines);
                    }
                } else {
                    if (rmdir(name) == -1) {
                        snprintf(g_output, CF_BUFSIZE*2, 
                            "Delete directory %s failed\n", path);
                        CfLog(cferror, g_output, "unlink");
                    } else {
                        AddMultipleClasses(tlp->defines);
                    }
                }
            } else {
                int ret=false;

                if (tlp->compress == 'y') {
                    CompressFile(name);
                } else if ((ret = unlink(name)) == -1) {
                    snprintf(g_output,CF_BUFSIZE*2,
                            "Couldn't unlink %s tidying\n",path);
                    CfLog(cfverbose,g_output,"unlink");
                }

                snprintf(g_output,CF_BUFSIZE*2,"Deleting file %s\n",path);
                CfLog(cfinform,g_output,"");
                snprintf(g_output, CF_BUFSIZE*2,
                        "Size=%d bytes, %c-age=%d days\n",
                        statbuf->st_size,tlp->searchtype,
                        (nowticks-fileticks)/CF_TICKS_PER_DAY);
                CfLog(cfverbose,g_output,"");

                if (ret != -1) {
                    AddMultipleClasses(tlp->defines);
                }
            }
        } else {
            if (tlp->compress == 'y') {
                printf("%s: want to compress %s\n",g_vprefix,path);
            } else {
                printf("%s: want to delete %s\n",g_vprefix,path);
            }
        }
    } else {
        Debug2("(No age match)\n");
    }
}


/* ----------------------------------------------------------------- */

void
DeleteTidyList(struct TidyPattern *list)
{
    if (list != NULL) {
        DeleteTidyList(list->next);
        list->next = NULL;

        if (list->classes != NULL) {
            free (list->classes);
        }

        free((char *)list);
    }
}
